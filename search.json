[{"title":"Hello World","url":"/2026/01/19/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"【PCL】主题、更新与CDN的破解（未完成）","url":"/2026/01/19/%E3%80%90PCL%E3%80%91%E4%B8%BB%E9%A2%98%E3%80%81%E6%9B%B4%E6%96%B0%E4%B8%8ECDN%E7%9A%84%E7%A0%B4%E8%A7%A3%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89/","content":"反编译由于太菜我没能知道 PCL 快照版加的什么壳，试着使用了 .NET Reactor Slayer，成功脱去了大部分内容。\n脱壳后使用 dnSpy 反编译得到源代码。\n先纵览 ModSecret 的源代码，得到本次反编译的目标：\n\n主题相关内容\n\n更新相关内容\n\n网络鉴权相关内容\n\n\n主题主题相关内容共分两部分：秋仪金和其他主题\n其他主题首先可以发现主题的存储是通过 ModSetup 来注册的，注册项的名称是 UiLauncherThemeHide2 。\n这里给出注册代码：\nMe.SetupDict = New Dictionary(Of String, ModSetup.SetupEntry)() From &#123; ...&#123; &quot;UiLauncherThemeHide2&quot;, New ModSetup.SetupEntry(&quot;0|1|2|3|4&quot;, ModSetup.SetupSource.Registry, True) &#125;  ...&#125;\n\n可以看到最后一个参数值为 True ，阅读 SetupEntry 的初始化函数定义：\nPublic Sub New(Value As Object, Optional Source As Object = 0, Optional Encoded As Object = False)\n\n发现最后一个参数为 Encoded，也就是进行了加密。下方调用了 ModSecret.SecretEncrypt 这个函数，我们直接看代码：\n&#x27; Token: 0x06000612 RID: 1554 RVA: 0x00035B34 File Offset: 0x00033D34Friend Function SecretEncrypt(SourceString As String, Optional Key As String = &quot;&quot;) As String    Key = ModSecret.SecretKeyGet(Key)    Dim bytes As Byte() = Encoding.UTF8.GetBytes(Key)    Dim bytes2 As Byte() = Encoding.UTF8.GetBytes(&quot;95168702&quot;)    Dim descryptoServiceProvider As DESCryptoServiceProvider = New DESCryptoServiceProvider()    Dim text As String    Using memoryStream As MemoryStream = New MemoryStream()        Dim bytes3 As Byte() = Encoding.UTF8.GetBytes(SourceString)        Using cryptoStream As CryptoStream = New CryptoStream(memoryStream, descryptoServiceProvider.CreateEncryptor(bytes, bytes2), CryptoStreamMode.Write)            cryptoStream.Write(bytes3, 0, bytes3.Length)            cryptoStream.FlushFinalBlock()            text = Convert.ToBase64String(memoryStream.ToArray())        End Using    End Using    Return textEnd Function&#x27; Token: 0x06000613 RID: 1555 RVA: 0x00035BEC File Offset: 0x00033DECFriend Function SecretDecrypt(SourceString As String, Optional Key As String = &quot;&quot;) As String    Key = ModSecret.SecretKeyGet(Key)    Dim bytes As Byte() = Encoding.UTF8.GetBytes(Key)    Dim bytes2 As Byte() = Encoding.UTF8.GetBytes(&quot;95168702&quot;)    Dim descryptoServiceProvider As DESCryptoServiceProvider = New DESCryptoServiceProvider()    Dim [string] As String    Using memoryStream As MemoryStream = New MemoryStream()        Dim array As Byte() = Convert.FromBase64String(SourceString)        Using cryptoStream As CryptoStream = New CryptoStream(memoryStream, descryptoServiceProvider.CreateDecryptor(bytes, bytes2), CryptoStreamMode.Write)            cryptoStream.Write(array, 0, array.Length)            cryptoStream.FlushFinalBlock()            [string] = Encoding.UTF8.GetString(memoryStream.ToArray())        End Using    End Using    Return [string]End Function\n\n这两个函数的逻辑很简单，是 DES 加密，里面要用到这个工具函数：\nPrivate Function SecretKeyGet(Key As String) As String    Dim text As String    If ModBase.ApplicationStartTick &lt; 1L Then        text = &quot;00000000&quot;    ElseIf String.IsNullOrEmpty(Key) Then        text = &quot;@;$ Abv2&quot; &#x27;注意这里的空值处理逻辑。    Else        text = Strings.Mid(ModBase.StrFill(Conversions.ToString(ModBase.GetHash(Key)), &quot;X&quot;, 8), 1, 8)    End If    Return textEnd Function\n\n而它又要用到以下函数：\nPublic Function StrFill(Str As String, Code As String, Length As Byte) As String    Dim text As String    If Str.Length &gt; CInt(Length) Then        text = Strings.Mid(Str, 1, CInt(Length))    Else        &#x27; The following expression was wrapped in a checked-expression        text = Strings.Mid(Str.PadRight(CInt(Length), Conversions.ToChar(Code)), Str.Length + 1) + Str    End If    Return textEnd FunctionPublic Function GetHash(Str As String) As ULong    Dim num As ULong = 5381UL    Dim num2 As Integer = Str.Length - 1    For i As Integer = 0 To num2        num = (num &lt;&lt; 5) Xor num Xor CULng(Str(i))    Next    Return num Xor 12218072394304324399ULEnd Function\n\n接下来我们来看看它是如何存储的：\n&#x27; Token: 0x06000619 RID: 1561 RVA: 0x00036778 File Offset: 0x00034978Friend Function ThemeUnlock(Id As Integer, Optional ShowDoubleHint As Boolean = True, Optional UnlockHint As String = Nothing) As Boolean    Dim flag As Boolean    If ModMain.FrmMain Is Nothing Then        flag = False    Else        ModBase.Log(&quot;[UI] 解锁隐藏主题：&quot; + Conversions.ToString(Id), ModBase.LogLevel.Normal, &quot;出现错误&quot;)        If Id = 8 Then            Throw New Exception(&quot;不可使用此方式解锁秋仪金！&quot;)        End If        Dim list As List(Of String) = New List(Of String)(ModBase.Setup.[Get](&quot;UiLauncherThemeHide2&quot;, Nothing).ToString().Split(&quot;|&quot;))        If list.Contains(Id.ToString()) Then            If ShowDoubleHint Then                ModMain.Hint(&quot;该隐藏主题已被解锁！&quot;, ModMain.HintType.Blue, True)            End If            flag = False        Else            If UnlockHint IsNot Nothing Then                ModMain.Hint(UnlockHint, ModMain.HintType.Green, False)            End If            list.Add(Id.ToString())            ModBase.Setup.[Set](&quot;UiLauncherThemeHide2&quot;, list.ToArray().Join(&quot;|&quot;), False, Nothing)            ModSecret.ThemeCheckAll(True)            flag = True        End If    End If    Return flagEnd Function\n\n这里可以看到它使用|分割每个主题编号，因此我们只需要把以下内容：\n0|1|2|3|4|5|6|7|9|10|11|12|13\n\n加密并写入注册表UiLauncherThemeHide2即可解锁所有主题（这里不写8是因为8代表秋仪金）。\n另外，这里 SecretEncrypt 函数的调用藏得很深，在ModSetup中的Set方法里，如下：\nValue = ModSecret.SecretEncrypt(Conversions.ToString(Value), &quot;PCL&quot; + ModBase.Identify)\n\n这里用到了ModBase.Identity作为Key的一部分，因此我们顺便来看看识别码的生成逻辑（在ModSecret中）：\n&#x27; Token: 0x0600060D RID: 1549 RVA: 0x00035398 File Offset: 0x00033598Friend Function SecretGetIdentify() As String    Dim text As String    Try        If ModBase.ApplicationStartTick &lt; 1L Then            text = &quot;0000-0000-0000-0000&quot;        Else            Dim text2 As String            Try                text2 = MyWpfExtension.Computer.Registry.GetValue(String.Format(&quot;HKEY_LOCAL_MACHINE\\SYSTEM\\Har&#123;0&#125;wareConfig&quot;, &quot;D&quot;.ToLower()), &quot;LastConfig&quot;, &quot;Unknown&quot;).ToString().ToUpper().Trim(New Char() &#123; &quot;&#123;&quot;c, &quot;&#125;&quot;c &#125;)            Catch ex As Exception                ModBase.Log(ex, &quot;获取主板标识码失败&quot;, ModBase.LogLevel.Debug, &quot;出现错误&quot;)                text2 = &quot;Unknown&quot;            End Try            Dim text3 As String            Try                text3 = Conversions.ToString(ModBase.Setup.[Get](&quot;Identify&quot;, Nothing))            Catch ex2 As Exception                text3 = &quot;&quot;            End Try            If text3.Length &lt; 3 Then                text3 = Conversions.ToString(ModBase.GetTimeTick()) + Conversions.ToString(MyWpfExtension.Computer.Info.AvailablePhysicalMemory)                ModBase.Setup.[Set](&quot;Identify&quot;, text3, False, Nothing)            End If            Dim text4 As String = ModBase.StrFill(ModBase.GetHash(text2 + text3).ToString(&quot;X&quot;), &quot;7&quot;, 16)            text = String.Format(&quot;&#123;0&#125;-&#123;1&#125;-&#123;2&#125;-&#123;3&#125;&quot;, New Object() &#123; Strings.Mid(text4, 5, 4), Strings.Mid(text4, 13, 4), Strings.Mid(text4, 1, 4), Strings.Mid(text4, 9, 4) &#125;)        End If    Catch ex3 As Exception        ModBase.Log(ex3, &quot;PCL 无法获取设备标识码，这可能会导致部分设置无法正常存储。&quot; &amp; vbCrLf &amp; vbCrLf &amp; &quot;详细的错误信息&quot;, ModBase.LogLevel.Feedback, &quot;获取标识码失败&quot;)        text = &quot;0000-0000-0000-0000&quot;    End Try    Return textEnd Function\n\n这里根据的是内存和主板信息，所以可以很轻松的在其他语言还原这段逻辑，例如 Python：\ndef secret_get_unique_address() -&gt; str:    try:        board_id = read_reg(            winreg.HKEY_LOCAL_MACHINE,            r&quot;SYSTEM\\HardwareConfig&quot;,            &quot;LastConfig&quot;,            &quot;Unknown&quot;        ).upper().strip(&quot;&#123;&#125;&quot;)        identify = read_reg(            winreg.HKEY_CURRENT_USER,            r&quot;Software\\PCL&quot;,            &quot;Identify&quot;,            &quot;&quot;        )        if len(identify) &lt; 3:            tick = int(time.time() * 1000)            mem = psutil.virtual_memory().available            identify = f&quot;&#123;tick&#125;&#123;mem&#125;&quot;            write_reg(                winreg.HKEY_CURRENT_USER,                r&quot;Software\\PCL&quot;,                &quot;Identify&quot;,                identify            )        h = int(get_hash_str(board_id + identify))        hex_str = str_fill(format(h, &quot;X&quot;), &quot;0&quot;, 16)        result = (            f&quot;&#123;hex_str[4:8]&#125;-&quot;            f&quot;&#123;hex_str[12:16]&#125;-&quot;            f&quot;&#123;hex_str[0:4]&#125;-&quot;            f&quot;&#123;hex_str[8:12]&#125;&quot;        )        return result    except Exception as e:        print(f&quot;ERROR get_unique_addr: &#123;e&#125;&quot;)        print_exc()        print(&quot;WARNING get_unique_addr: Returning value 0000-0000-0000-0000 which is invalid.&quot;)        return &quot;0000-0000-0000-0000&quot;\n\n这样，我们就还原了主题生成与解锁验证所需的全部流程逻辑。\n通过上面给过的 SecretEncrypt 函数，我们可以轻松写一个用来生成主题注册表项的 Python 小脚本。相关代码已经开源在 GitHub ，其中的main.py就可以生成注册表项了（生成识别码的逻辑单独放在get_unique_address.py中）。\n概括一下所有流程：\n原字符串（用|分割的主题编号）&#x3D;&gt; 使用SecretEncrypt加密（密钥为PCL+识别码） &#x3D;&gt; 写入注册表项UiLauncherThemeHide2\n至此，我们已经破解了除秋仪金的大部分主题。\n秋仪金之所以把秋仪金放在后面讲，是因为它更难破解。\n我们先来观察秋仪金的解锁和验证逻辑：\n&#x27; Token: 0x0600061A RID: 1562 RVA: 0x00036848 File Offset: 0x00034A48Friend Function ThemeCheckGold(Optional Code As String = Nothing) As Boolean    Dim flag As Boolean    Try        Dim text As String = (If(Code, ModBase.Setup.[Get](&quot;UiLauncherThemeGold&quot;, Nothing))).ToString().Replace(&quot;#&quot;, &quot;&quot;)        flag = ModSecret.SecretRsaVerify(&quot;Gold|0|&quot; + ModBase.Identify.Replace(&quot;-&quot;, &quot;&quot;), text)    Catch ex As Exception        ModBase.Log(ex, &quot;检查秋仪金失败&quot;, ModBase.LogLevel.Feedback, &quot;出现错误&quot;)        flag = False    End Try    Return flagEnd FunctionFriend Function SecretRsaVerify(SourceString As String, Sign As String) As Boolean    Dim flag As Boolean    Try        If ModBase.ApplicationStartTick &lt; 1L Then            flag = False        Else            Dim rsacryptoServiceProvider As RSACryptoServiceProvider = New RSACryptoServiceProvider(512)            rsacryptoServiceProvider.FromXmlString(ModSecret.SecretRsaPublicKey.Replace(&quot;!&quot;, &quot;&quot;).Replace(&quot;$&quot;, &quot;+&quot;) + &quot;/R1Frckd3/Sn+Zsx9aD6U2f&quot; + Conversions.ToString(Math.Round(84D)) + &quot;SdWMDlrRY9DfhQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;\\Exponent&gt;&lt;\\RSAKeyValue&gt;&quot;.Replace(&quot;\\&quot;, &quot;/&quot;))            flag = rsacryptoServiceProvider.VerifyData(Encoding.[Default].GetBytes(SourceString), GetType(SHA256), Convert.FromBase64String(Sign))        End If    Catch ex As Exception        flag = False    End Try    Return flagEnd Function\n\n这里可以发现验证使用的是 RSA 非对称加密 ，严格意义上来说除非拥有私钥，无法进行签名。但真的是这样吗？我们不能畏难。仔细阅读，发现其中使用的是 RSA 512。这是早已被淘汰且被证实不安全的 RSA 密钥长度。\n私钥的破解过程接下来讲解破解 RSA 公钥的过程，不感兴趣的同学可以直接跳过。\n首先观察程序，拿到其中的公钥。\n&#x27; Token: 0x04000409 RID: 1033Friend SecretRsaPublicKey As String = &quot;&lt;RS!AKeyValu!e&gt;&lt;Mo!dul!us&gt;0L/cZoJUyBRAIE8OKiG8$qYOytXD$azFCBsmOuQra&quot;\n\n和处理流程：\nrsacryptoServiceProvider.FromXmlString(ModSecret.SecretRsaPublicKey.Replace(&quot;!&quot;, &quot;&quot;).Replace(&quot;$&quot;, &quot;+&quot;) + &quot;/R1Frckd3/Sn+Zsx9aD6U2f&quot; + Conversions.ToString(Math.Round(84D)) + &quot;SdWMDlrRY9DfhQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;\\Exponent&gt;&lt;\\RSAKeyValue&gt;&quot;.Replace(&quot;\\&quot;, &quot;/&quot;))\n\n进行还原后发现公钥的长度不对头，因此再次观察，发现在ModSecret初始化时非常隐蔽的对SecretRsaPublicKey的值做了修改，如下：\nModSecret.SecretRsaPublicKey = ModSecret.SecretRsaPublicKey + &quot;qgaq&quot;.ToUpper() + &quot;1S&quot;\n\n（在SecretOnApplicationStart函数的末尾，我花了很久才找到……）\n因此可还原出 RSA 公钥：\n&lt;RSAKeyValue&gt;&lt;Modulus&gt;0L/cZoJUyBRAIE8OKiG8+qYOytXD+azFCBsmOuQraQGAQ1S/R1Frckd3/Sn+Zsx9aD6U2f84SdWMDlrRY9DfhQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;\n\n提取出模数并转换为十进制，以便因式分解：\n10933096180346127695081099708243448444467282953548374941920090181459099156162822929023598405197953653590303042837761938376403948824104176832254366232665989\n\n这个数虽然可以使用 yafu 因式分解，但是这太依赖性能，需要跑整整一个月。鉴于这个数相对较小，因此我们可以去 FactorDB 上找一找，能找到的概率很大。\n果不其然：\n\n这个数的状态是 FF（Fully Factored），也就是已经被分解过了。看到后面的两个 Number 值，就是这里的唯二两个因数。\n通过两个因数（p）还原私钥的过程太繁琐，我这里不再赘述，感兴趣的同学可以自己搜索。还原后可以再转换为通用的 PEM 格式，方便后续使用。这里我就不把私钥放出来了。\n私钥验证现在我们已经有了私钥，下一步就是根据原文生成签名。\n先看看函数调用：\nflag = ModSecret.SecretRsaVerify(&quot;Gold|0|&quot; + ModBase.Identify.Replace(&quot;-&quot;, &quot;&quot;), text)\n\n这里的原文是Gold|0|+识别码。识别码生成流程上面说过了。\n由此我们只需要使用 RSA 对 Gold|0|+识别码 这个字符串进行签名即可。\nRSA 签名相关代码放在了  GitHub 仓库下的 gold.py（私钥已经放在 repo secret 里面了）。\n更新更新密钥的验证也需要使用 RSA 生成签名，这在上面已经说过。\n这里放上验证逻辑：\nCS$&lt;&gt;8__locals1.$VB$Local_NewUniqueMark = ModSecret.GetUniqueMark(ReceivedKey)Dim array As String() = ReceivedKey.Replace(&quot;1&quot;, &quot;=&quot;).Replace(&quot;-&quot;, &quot;1&quot;).Replace(&quot;0&quot;, &quot;\\&quot;).Replace(&quot;*&quot;, &quot;0&quot;).Split(&quot;\\&quot;)CS$&lt;&gt;8__locals1.$VB$Local_UpdateKey = ModSecret.SecretDecrypt(array(0), array(1))If ModSecret.SecretRsaVerify(CS$&lt;&gt;8__locals1.$VB$Local_UpdateKey + array(1) + ModBase.Identify, array(2)) OrElse Not ModSecret.SecretRsaVerify(ModBase.Identify + CS$&lt;&gt;8__locals1.$VB$Local_UpdateKey + array(1), array(2)) Then    Throw New Exception(&quot;更新密钥验证失败。&quot;)End If\n\n这里的CS$&lt;&gt;8__locals1.$VB$Local_UpdateKey，为了不与更新密钥本身相混淆，我们称它作 “remote update key”，即远程更新密钥。\n因此我们可以获取更新密钥的结构：\n识别码 + 远程更新密钥 + array(1)\n这里的 array(1) 是自验证，可以随便取一个 base64，因此是盐值（？）。\n将它们按顺序组合在一起并使用\\做分割，即可获取更新密钥明文。\n对该明文使用 RSA 签名即可获取更新密钥。\n此处的远程更新密钥没有直接说，但是瞎填会导致提示”更新密钥失效“，再次阅读发现它参与了更新 URL 的构成，因此如果填错会导致 404。我们只能通过解密一个已知对本机有效的更新密钥来还原出远程更新密钥的值。\n这里进行还原，可以得到这个值为linkv3（在 2025&#x2F;8&#x2F;12 获取）或linkv4（在 2025&#x2F;11&#x2F;3 获取），并且有且只有这两个值才能使得更新成功进行。\n该段逻辑已经放在了 GitHub 仓库下的 update_key.py 中。\n网络鉴权这部分主要依赖以下两个函数：\nFriend Function SecretCdnSign(UrlWithMark As String) As String    Dim text As String    If ModBase.ApplicationStartTick &lt; 1L Then        text = UrlWithMark    ElseIf Not UrlWithMark.EndsWithF(&quot;&#123;CDN&#125;&quot;, False) Then        text = UrlWithMark    Else        Dim text2 As String = UrlWithMark.Replace(&quot;&#123;CDN&#125;&quot;, &quot;&quot;).Replace(&quot; &quot;, &quot;%20&quot;)        Dim text3 As String = ModBase.StrFill(ModBase.RandomInteger(0, 2147483645).ToString(&quot;x&quot;), &quot;0&quot;, 8)        Dim text4 As String = ModSecret.SecretDecrypt(&quot;VwHB1je1uabAr0gKijpFaQ==&quot;, &quot;CDN&quot;)        Dim text5 As String = Conversions.ToString(ModBase.GetUnixTimestamp())        Dim text6 As String = text2.Substring(text2.IndexOfF(&quot;://&quot;, False) + 3)        text6 = text6.Substring(text6.IndexOfF(&quot;/&quot;, False))        Dim stringMD As String = ModBase.GetStringMD5(New String() &#123; text6, text5, text3, &quot;0&quot;, text4 &#125;.Join(&quot;-&quot;))        text = text2 + If(text2.Contains(&quot;?&quot;), &quot;&amp;&quot;, &quot;?&quot;) + &quot;sign=&quot; + New String() &#123; text5, text3, &quot;0&quot;, stringMD &#125;.Join(&quot;-&quot;)    End If    Return textEnd FunctionFriend Sub SecretHeadersSign(Url As String, ByRef Req As HttpRequestMessage, Optional SimulateBrowserHeaders As Boolean = False)    If ModBase.ApplicationStartTick &gt;= 1L Then        If Not Req.Headers.UserAgent.Any() Then            If Not Url.Contains(&quot;baidupcs.com&quot;) AndAlso Not Url.Contains(&quot;baidu.com&quot;) Then                If SimulateBrowserHeaders Then                    Req.Headers.Add(&quot;User-Agent&quot;, String.Format(&quot;PCL2/&#123;0&#125; Mozilla/5.0 AppleWebKit/537.36 Chrome/63.0.3239.132 Safari/537.36&quot;, &quot;2.12.1.0&quot;))                Else                    Req.Headers.Add(&quot;User-Agent&quot;, String.Format(&quot;PCL2/&#123;0&#125;&quot;, &quot;2.12.1.0&quot;))                End If            Else                Req.Headers.Add(&quot;User-Agent&quot;, &quot;LogStatistic&quot;)            End If        End If        If Not SimulateBrowserHeaders Then            Req.Headers.Referrer = New Uri(String.Format(&quot;http://&#123;0&#125;.pcl2.server/&quot;, 378))        End If        If Url.Contains(ModSecret.SecretDecrypt(&quot;kSHbgKrsiOuHY81i63QtJevaX2+IWvVT&quot;, &quot;&quot;)) Then            Req.Headers.Add(ModSecret.SecretDecrypt(&quot;hlBzlKCNcyEYEaSOd0Vx0w==&quot;, &quot;&quot;), ModSecret.SecretDecrypt(&quot;SA+taZSvSkfRoq0fW5pnIpFzDGDck82KzMPbuglfAqrAbQAOwcZXBXVQVzenSNP14fnexB+G1bV/ufvjrtpiUA==&quot;, &quot;&quot;))        End If    End IfEnd Sub\n\n在上面SecretHeadersSign里面最后一个 If 条件判断的字符串解密出来是curseforge.com……\nUrlWithMark里面的”mark“指的是&#123;CDN&#125;标识，这个表示最终会被替换为一串sign=...的签名字符串。\n签名的逻辑太过繁杂了，这里不说了，用到的工具函数前面都讲过。\n该段代码未上传 GitHub。\n但是，我们来看看里面名叫DownloadLatestPCL函数，如果能直接下载更新包，那么都用不着生成更新密钥了，岂不美哉：\nFriend Sub DownloadLatestPCL(Optional LoaderToSyncProgress As ModLoader.LoaderBase = Nothing)    Dim objectValue As Object = RuntimeHelpers.GetObjectValue(If(File.Exists(ModBase.PathTemp + &quot;Latest.exe&quot;), ModBase.Setup.[Get](&quot;SystemHighestSavedBetaVersionReg&quot;, Nothing), 0))    Dim text As String = ModBase.ReadFile(ModBase.PathTemp + &quot;Cache\\Notice.cfg&quot;, Nothing)    Dim num As Integer    If text.Split(&quot;|&quot;).Count() &lt; 3 Then        num = 0    Else        num = Conversions.ToInteger(text.Split(&quot;|&quot;)(2))    End If    If Not Operators.ConditionalCompareObjectGreaterEqual(objectValue, num, False) Then        ModBase.Log(Conversions.ToString(Operators.ConcatenateObject(Operators.ConcatenateObject(Operators.ConcatenateObject(&quot;[Server] 需要下载最新正式版：&quot;, objectValue), &quot; -&gt; &quot;), num)), ModBase.LogLevel.Normal, &quot;出现错误&quot;)        ModNet.NetDownloadByLoader(New String() &#123; &quot;https://github.com/Meloong-Git/PCL/raw/main/%E6%9C%80%E6%96%B0%E6%AD%A3%E5%BC%8F%E7%89%88.zip&quot;, String.Format(&quot;https://pcl2-server-1253424809.file.myqcloud.com/update/&#123;0&#125;.zip&#123;&#123;CDN&#125;&#125;&quot;, &quot;Publi3&quot;) &#125;, ModBase.PathTemp + &quot;Latest.zip&quot;, LoaderToSyncProgress, New ModBase.FileChecker(1048576L, -1L, Nothing, True, False), False)        ModBase.ExtractFile(ModBase.PathTemp + &quot;Latest.zip&quot;, ModBase.PathTemp, Nothing, Nothing)        File.Delete(ModBase.PathTemp + &quot;Latest.zip&quot;)        File.Delete(ModBase.PathTemp + &quot;Latest.exe&quot;)        FileSystem.Rename(ModBase.PathTemp + &quot;Plain Craft Launcher 2.exe&quot;, ModBase.PathTemp + &quot;Latest.exe&quot;)        ModBase.Setup.[Set](&quot;SystemHighestSavedBetaVersionReg&quot;, num, False, Nothing)    End IfEnd Sub\n\n但是……这一部分我虽然还原出了上述两个函数，却仍未能破解出来……\n这就是标题里面”（未完成）“的含义了。\n结束语PCL 作为一个反编译拿来练手的项目我认为是相当不错的。\n首先，它的项目体积足够让人晕头转向，但是又不至于让电脑都炸掉。里面蛛丝马迹很多。同时其外表做很多鉴权的函数给人一种假象，其实破解并不是很难。这里留下了很多漏洞和可以练习的地方，因此非常适合给想要练手的人玩玩。\n反编译涉及到的编程知识面非常广，例如 RSA 部分需要你学习一点数学知识，同时多语言的转换还有助于你熟悉两种语言的思维模式\n作为一个之前没有反编译过任何一个项目的人，我非常喜欢这种解密的感受。\n基于本文章还原的 Python 破解脚本代码已经公开在 https://github.com/Ignis-Studio/PCLThemeUnlock ，可供参考。\n感谢阅读。\n参考文献\nPCL2的反编译以及主题破解(除秋仪金)(修改版)  · TheZihanGu · 洛谷专栏\n\nPCL 反编译——加密和解密原理记录 - 盐木的小破窝 · SaltWood233 · 个人博客\n\n\n","tags":["PCL","技术","观点"]},{"title":"【PCL】我对联机事件的一些看法","url":"/2025/11/28/%E3%80%90PCL%E3%80%91%E6%88%91%E5%AF%B9%E8%81%94%E6%9C%BA%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/","content":"争端2025 年 1 月 11 日，「Terracotta｜陶瓦联机」发布了第一个版本，从而开始了国内 MC 启动器重新开启联机功能的第二波潮流。它借助于 EasyTier 组网工具，实现了点对点的打洞联机功能，为后续的所有联机模块提供了基本思路。自此，启动器内置联机的竞争出现了。7 月， PCL-CE 也实现了基于 EasyTier 联机功能，后续成功兼容了 Terracotta，并计划实现一套可以跨启动器联机的协议：Scaffolding（后面会提到）10 月下旬， PCL （上游）官方宣布 “联机回归！”\n这次， PCL 使用了自研的 [“简洁联机标记约定”（PCL 约定）]( 简洁联机标记约定 · Meloong-Git&#x2F;PCL Wiki ) 。但不变的是，此协议依然采用了 EasyTier 组网作为模块核心。10 月下旬开始， EasyTier 的核心节点服务器由于持续的攻击和超过预期的流量，开始崩溃。而社区舆论也开始从赞扬开源精神，转向了质疑。\n后续，PCL CE 和 PCL 都先后关闭了联机服务。\n关闭的主要原因有三点，这在龙腾猫跃的动态里面说的很清楚：\n\n这里提到了“合规性有着一些问题“，那么问题在哪里呢？\n合规性答案就在一切的根源：EasyTier。\nEasyTier 是一款“远程组网工具“。它将主机和房间成员的电脑连接到同一个”虚拟局域网“。这里的虚拟局域网和普通局域网没有本质区别，因此它也不止可以被用来进行局域网联机，还能用来进入学校、公司等的内网，访问内网中的文件等服务。\nEasyTier 在服务中使用如下原理。首先，主机电脑通过 EasyTier 向“中心节点服务器“发送请求，被分配到一个子节点地址。接下来，主机电脑连接到子节点，尝试通过子节点进行“打洞”来建立一个“P2P”（点对点）连接。但是在普通情况下打洞有可能失败，于是则会使用子节点来转发流量到对方服务器（中继）。一旦建立稳定连接，则可以通过 EasyTier 来向虚拟局域网中的其他成员电脑发送信息。\n因此，所谓的合规性问题就在于：通过中继服务器在两台电脑之间建立信道，这件事到底违规不违规？\n其实，组网工具就是一个广义上的 VPN（Virtual Private Network）服务。如果成员主机在境外，抑或是传输了违规的信息，那么整个服务就与违法的翻墙服务没有任何区别。但是请注意，如果没有进行违规服务，也没有跨境，那么 VPN 本身并不违法。也就是说：VPN ≠ 翻墙。\n但是，不管是 Scaffolding、PCL 协议还是 Terracotta，这其中都没有实现任何对流量的审查。既没有限制其只能转发 Minecraft 流量，也没有检查主机是否位于境外。同样，EasyTier 的节点也没有检查通过其中的流量。这就意味着：只要你想，你可以通过 EasyTier 随意向位于国外的主机转递非法流量，只要你们建立了同一个虚拟局域网。\n所以，这就是各种视频里面宣传的 “请立刻停止为 PCL 贡献节点”之类的源头。里面持有的观点不外乎是：搭建节点，就等于搭建 VPN，就等于违法。如果你搭建了节点，那很可能被一起追责。就算是合规运营，很多服务商的条例里也禁止提供中继服务，这也很可能是EasyTier被服务商诟病的原因。\n这其实是利用了所有人对于“VPN”这个词的恐慌心理。只要建立了恰当的流量审查，在恰当的厂商搭建，那么 EasyTier 等组网 VPN 服务，一样可以安全存在。\n最后一根稻草再来看第一、三个问题。\n这些“带节奏”和“攻击”的源头是哪里？就是运营商……\n\n那些视频 IP 都是黑龙江，发布时间和封面标题也很一致，都是云服务商（\n\n云服务商其实本身就很抵制内网穿透这些东西，那么发视频的原因也很明确了……\n事实上，大多数节点的负载是源于攻击，而不是来自 Minecraft 联机。更有通过节点走加密流量的，反正不是在联机。\n接下来，经过有组织预谋的舆论导向，联机功能的齿轮开始不堪重负，渐渐停转……\n11月16日，PCL CE联机入口正式关闭：\n接下来，PCL 的联机入口也相继关闭。\n联机崩溃的根本原因，就在于吹捧过度，运营商攻击，节点不堪重负（由于攻击）以及曲解“VPN”含义造成的群体被害妄想。\n恢复？11月19日，龙腾猫跃发布了一篇新动态：报告！最新进展！。\n\n我只希望联机能够快点回归……吧。\n利益这种东西，还是太复杂了。\n毕竟，这只是一个游戏的功能而已。\n一些其他的话龙猫本人似乎不太满意 谁在台前发电，谁在背后扛压力 这篇文章…… 这篇文章里面有些语句似乎在暗指是各大启动器对该服务的滥用导致了 EasyTier 的崩溃。在这里澄清一下，联机功能崩溃的本质原因就是运营商的炒作和攻击（当然后者很有可能是前者引发的），而不是由于启动器造成的负载。事实上，如果节点仅仅用于打洞，负载是相当之低的，完全不可能造成崩溃。\n我对此事的感想是：一个工具只要出圈，基本就等于招致诟病和践踏。毕竟，林子大了什么鸟都有……此事的根本原因即是联机功能被大肆炒作导致的，这让运营商注意到了这个功能，才出现后续的事件。事实上，PCL CE 等本身就是被作为一个小工具考虑的，可是一旦被 UP 主等等注意到，就会宣传。我非常讨厌大肆宣传炒作不成熟工具的人，例如将 PCL CE 炒作为 “PCL 增强版” 等。\n这可能听起来十分反直觉，但项目出圈有时即是出局。\n参考文献龙腾猫跃的个人空间-bilibili：https://space.bilibili.com/11343203\nPCL 联机功能（再次）暂时关闭的说明……-bilibili by 龙腾猫跃：https://www.bilibili.com/opus/1135872352762986504\nEasyTier 文档-EasyTier官网：EasyTier - 简单、安全、去中心化的异地组网方案\n当 PCL 联机遇上 EasyTier：谁在台前发电，谁在背后扛压力-bilibili by Qihuang02-https://www.bilibili.com/opus/1136282681104924672\n简洁联机标记约定 · Meloong-Git&#x2F;PCL Wiki-GitHub by 龙腾猫跃：https://github.com/Meloong-Git/PCL/wiki/%E7%AE%80%E6%B4%81%E8%81%94%E6%9C%BA%E6%A0%87%E8%AE%B0%E7%BA%A6%E5%AE%9A\n陶瓦联机-GitHub by BurningTNT：https://github.com/burningtnt/Terracotta\n","tags":["PCL","技术","观点"]},{"title":"【技术】家里云的三百六十五里路啊~","url":"/2025/12/28/%E3%80%90%E6%8A%80%E6%9C%AF%E3%80%91%E5%AE%B6%E9%87%8C%E4%BA%91%E7%9A%84%E4%B8%89%E7%99%BE%E5%85%AD%E5%8D%81%E4%BA%94%E9%87%8C%E8%B7%AF%E5%95%8A/","content":"第一劫：公网 IP 大乱斗我一直很想开一个 Minecraft 服务器，但是我不喜欢那种命运被服务商掌控的感觉，更没有钱去交给服务商。说实话，我一直很讨厌付钱（谁不讨厌呢？），虽然我尝试过在 Vercel 和 GitHub Pages 上面部署几个站点，但这速度……十分堪忧。\n我决定要部署家里云了。我爸宣布他要买个千兆宽带，这本来和我没啥关系，然后我听到“附送公网 IP”，我立马兴奋了。反正我是去申请了一个。\n然后呢？他妈的，ipw.cn 告诉我：对不起，你没有公网 IP。总不可能是电信骗我吧？然后我问了半天，发现是 IPv6 的动态公网……并且我家路由器的 v6 功能支持……不能说是一点没有吧，只能说是糟透了。\n经过九牛二虎之力，我总算是开启了家里的 IPv6 功能，ipw.cn 总算显示公网 IP 了。\n第一劫总算过去了。\n第二劫：“云宽带”是啥？然后呢？然后我发现我的服务还是没法被公网访问……\n于是，按照网上的某乎教程，我想办法设置所谓的端口映射……\n接下来，我傻眼了：不在同一网段？？？\n我看了一下，路由器的 IP 是 192.168.1.1，设备的 IP 是 192.168.71.1……？\n这正常吗？这不正常。所以我干了相当正常的一件事……叫电信师傅来看。师傅老懂行了，过来直接说，你这是云宽带问题，去取消云宽带，给客服打电话。\n我一听：好嘞师傅！然后兴冲冲给客服打电话。客服也是游刃有余：取消云宽带是吧？线下签名！额……签好了？\n我回家，打开电脑，IP 变成 192.168.1.6 了。我配置完端口映射，您猜发生啥了？啥也没发生！端口映射想 Peach 呢？\n我问了一下 Gemini…… 防火墙？防火墙！路由器里没有防火墙啊——\n第三劫：”防火墙“的徒劳……我和 allMagic 聊了一下，嗯……就是那个在 PCL 仓库对萌新大开杀戒导致史无前例的被龙猫吊销 collab 执照的那位……\n他说：你这得要超密……\n我怎么可能弄得到超级管理员密码？高冷男神直接不说话让我自己搜。\n我搜到的方法有三种：\n通过 telnet 连接路由器然后偷密码这个是搜到最多，也是最狗屁不通的一个。\ntelnet 开启的那个接口网址早就被关闭了。退一万步说，就算现在我找到了密码文件，里面的内容也都是加密的……解个屁啊？（如果你说这是能解密的，看下去）\n通过网络共享 U 盘进入，然后修改网络请求到根目录，偷密码文件。嗯……不知道为啥修改之后的网络请求就没用了呢？\n点”备份配置“，从备份的配置文件里面解密解密的那个玩意没能解密成功。嗯……就这样。\n第四劫：改桥接最后联系电信的人改了桥接，过程太繁琐不说了，但是成功劝服我爸花百元巨款买了一台交换机。\n所以，买完之后还是没法从公网访问。\n那我为啥要说这一堆废话呢？我也不知道……\n哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈\n","tags":["技术"]}]